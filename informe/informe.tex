\documentclass[a4paper]{article}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{charter}   % tipografia
\usepackage{graphicx}

\usepackage{subfig}
\usepackage{float}
%\usepackage{makeidx}

%\usepackage{float}
%\usepackage{amsmath, amsthm, amssymb}
%\usepackage{amsfonts}
%\usepackage{sectsty}
%\usepackage{charter}
%\usepackage{wrapfig}
%\usepackage{listings}
%\lstset{language=C}


\input{codesnippet}
\input{page.layout}
% \setcounter{secnumdepth}{2}
\usepackage{underscore}
\usepackage{caratulaV}
\usepackage{url}
\usepackage{alltt}
\usepackage{tikz}
\usepackage{color}
\usepackage{gnuplottex}
\usepackage{verbatim}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
  numbers=left,
  xleftmargin=2em,
  frame=single,
  framexleftmargin=2em,
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\small\color{gray} % the style that is used for the line-numbers
 }



% ******************************************************** %
%              TEMPLATE DE INFORME ORGA2 v0.1              %
% ******************************************************** %
% ******************************************************** %
%                                                          %
% ALGUNOS PAQUETES REQUERIDOS (EN UBUNTU):                 %
% ========================================
%                                                          %
% texlive-latex-base                                       %
% texlive-latex-recommended                                %
% texlive-fonts-recommended                                %
% texlive-latex-extra?                                     %
% texlive-lang-spanish (en ubuntu 13.10)                   %
% ******************************************************** %






\begin{document}


\thispagestyle{empty}
\materia{Organización del Computador II}
\submateria{Primer Cuatrimestre - 2015}
\titulo{Trabajo Práctico II}
\subtitulo{Filtros de Imagen}
\integrante{Christian Cuneo}{755/13}{chriscuneo93@gmail.com}
\integrante{Ignacio Lebrero}{751/13}{ignaciolebrero@gmail.com}
\integrante{Jorge Porto}{376/11}{cuanto.p.p@gmail.com}

\maketitle
\newpage

\thispagestyle{empty}
\vfill
\begin{abstract}
Los filtros de imagen son una herramienta poderosa a la hora de retocar una imagen, usados ampliamente en fotografia, publicidad, videojuegos, etc.
Su uso brinda una gamma de opciones para modificar las imagenes de manera que sea mas flexible su edicion o analisis.\\
En este trabajo practico presentamos los metodos blur, merge y hsl ya existentes y los implementamos en lenguaje de ensamblador.
Damos dos implementaciones de cada filtro siendo la segunda una optimizacion de la primera en merge y blur, y una variacion de implementacion C/Assembler a Assembler en hsl.\\
Nuestros experimentos demuestran.....
\end{abstract}

\thispagestyle{empty}
\vspace{3cm}
\tableofcontents
\newpage

\thispagestyle{empty}
\vfill


\thispagestyle{empty}
\vspace{3cm}
\tableofcontents
\newpage

\begin{abstract}
En el presente trabajo se describe la problemática de ...
\end{abstract}

%\normalsize
\newpage


\begin{comment}
\begin{codesnippet}
\begin{verbatim}

struct Pepe {

    ...

};

\end{verbatim}
\end{codesnippet}
\end{comment}

\section{Intoducción}

El lenguaje C es uno de los más eficientes en cuestión de performance, pero esto no quiere decir que..

En este trabajo practico se realizan implementaciones en asembler..

\section{Desarollo}

%
% BLUR
%
\subsection{Blur}

El filtro blur genera una imagen desenfocada artificialmente, que usa un metodo muy simple para lograrlo, a cada pixel se lo promedia con todos sus pixeles vecinos y se guarda ese resultado en el mismo pixel.

\subsubsection{Implementación en Assembler 1}

El principio basico de la implementacion en assembler es que el barrido que se le hace a la imagen se realiza de arriba a abajo y de izquierda a derecha (viendo la imagen siempre como una matriz). Con este metodo se obtiene una ventaja muy interesante, uno reutiliza las filas ya cargadas a la hora de procesar el siguiente pixel, y solo tiene que cargar una fila mas por cada pixel a procesar, esto es una ventaja ya que uno busca una menor lectura de memoria, ya que es una tarea muy costosa. En el pseudocodigo siguiente se vera mas detalladamente el funcionamiento de este metodo:

% \begin{algorithm}%[t]
% \caption{Blur}
% \label{alg:insert}
% \begin{algorithmic}[1]
% \For { $x = 1 to (n - 2)$ }
% \State	$xmm1  \leftarrow  img[x-1][0] , img[x][0] , img[x+1][0] , img[x+2][0]$
% \State	$xmm2  \leftarrow  img[x-1][1] , img[x][1] , img[x+1][1] , img[x+2][1]$
% \State	$xmm1  \leftarrow  borrarprimero(xmm1)$
% \State	$xmm2  \leftarrow  borrarprimero(xmm2)$
% \State	$xmm1  \leftarrow  sumapixeles(xmm1)$
% \State	$xmm2  \leftarrow  sumapixeles(xmm2)$
% \For { $y = 1 to (n - 2):$ }
% \State		$xmm0  \leftarrow  xmm1$
% \State		$xmm1  \leftarrow  xmm2$
% \State		$xmm3  \leftarrow  img[x-1][y+1] , img[x][y+1] , img[x+1][y+1] , img[x+2][y+1]$
% \State		$xmm3  \leftarrow  borrarprimero(xmm3)$
% \State		$xmm3  \leftarrow  sumapixeles(xmm3)$
% \State		$xmm0  \leftarrow  xmm0 + xmm1 + xmm2$
% \State		$xmm0  \leftarrow  promedio(xmm0)$
% \State		$img[x][y]  \leftarrow  xmm0$
% \EndFor
% \EndFor
% \end{algorithmic}
% \end{algorithm}

\begin{lstlisting}
for (x = 1 to n - 2):
	xmm1  <--  img[x-1][0] , img[x][0] , img[x+1][0] , img[x+2][0]
	xmm2  <--  img[x-1][1] , img[x][1] , img[x+1][1] , img[x+2][1]
	xmm1  <--  borrarprimero(xmm1)
	xmm2  <--  borrarprimero(xmm2)
	xmm1  <--  sumapixels(xmm1)
	xmm2  <--  sumapixels(xmm2)
	for (y = 1 to n - 2): 
		xmm0  <--  xmm1
		xmm1  <--  xmm2
		xmm3  <--  img[x-1][y+1] , img[x][y+1] , img[x+1][y+1] , img[x+2][y+1]
		xmm3  <--  borrarprimero(xmm3)
		xmm3  <--  sumapixels(xmm3)
		xmm0  <--  xmm0 + xmm1 + xmm2
		xmm0  <--  promedio(xmm0)
		img[x][y]  <--  xmm0
	end
end
\end{lstlisting}

Cada pixel contiene 4 valores de 1 byte (R, G, B y A), por lo tanto entran 4 pixels en un registro xmm, entonces cargo directamente 4 pixels de memoria. Hay que tener en cuenta que se cargan los pixels del [x-1] al [x+2], pero en el registro van a quedar al revez, siendo primero el [x+2].
\newline

La funcion "borrarprimero" va a utilizar la instruccion PINSRD para insertar 0 en los primeros 4 bytes, eliminando asi los datos de el primer pixel en el registro, que seria el pixel x+2, ya que es el pixel que no nos interesa, porque solo hay que promediar con los vecinos del pixel img[x][y], es decir los pixeles img[i][j] con i$\in$(x-1, x , x+1) y j$\in$(y-1, y , y+1).
\newline

La funcion "sumarpixels" va a sumar los pixeles dentro del registro por valor (R, G, B y A). Para lograr esto sin saturacion se necesita extender (con ceros) los valores de 1 byte a 2 bytes, para poder representar sin nungun problema la suma de todos los valores posibles. Para esto se utiliza la instruccion PUNPCKLBW y PUNPCKHBW (ambas con un registro nulo como source), para guardar en un registro los 2 pixels menos significativos y los 2 pixels mas significativos respectivamente. Se necesita guardar en dos registros ya que al ocupar cada dato el doble, van a entrar la mitad de datos en el registro. Luego de extender los valores se procede a sumar horizontalmente cada registro y luego se suman de forma empaquetada a word los dos registros, y nos queda en el qword menos significativo el pixel suma de los pixels que habia originalmente en el registro.
\newline

La funcion "promedio", dado un registro con la suma (de todos los pixeles a promediar) en el qword menos significativo, va a devolver un pixel con cada valor original dividido por 9, y va a devolver este pixel de forma que quede listo para ser grabado a memoria (quiere decir los R, G, B y A de 1 byte cada uno y ordenados). Para ello primero extiende (con ceros) de word a dword cada valor del pixel, utilizando la instruccion PUNPCKLWD con un registro nulo como source. Luego se convierte cada valor de entero de 32 bits a single-precision floating point, que es tambien de 32 bits, con la instruccion CVTDQ2PS. Entonces se procede a dividirlos por 9 en forma empaquetada utilizando la instruccion DIVPS, usando como source un registro previamente cargado con cuatro "9" en float. Luego se van a convertir de nuevo a enteros utilizando la instruccion CVTPS2DQ. En este punto ya sabemos que no importe que valores hayan tenido los 9 pixeles sumados, al promediarlos van a dar numeros entre 255 y 0 unicamente, entonces al convertirlos de nuevo a enteros sabemos que van a quedar valores que van a ocupar como mucho los 8 bits menos significativos de cada dword. Teniendo en cuenta esa informacion se puede proceder a hacer un shuffle (con la instruccion PSHUFB) para mover cada byte menos significativo de cada dword a la posicion correcta del registro, quedando en el dword menos significativo del registro el pixel a guardar, con sus valores en el orden correcto. En esta instruccion se utiliza una mascara especifica que se puede ver en la implementacion.
\newline

Finalmente se graba a memoria el resultado utilizando la instruccion PEXTRD [mmx], xmm, 00b, siendo mmx el puntero al destino donde guardar los datos y xmm el resultado del promedio, se utiliza "00b" ya que el resultado de calcular el promedio se encuentra en el dword menos significativo.
\newline

Una cuestion a tener en cuenta de esta implementacion es que, al ser el array "img" la imagen a procesar y el destino donde guardar el resultado, se tuvo que asignar un espacio de igual tamaño al de "img" para guardar el resultado en ese espacio, ya que si se guarda en el mismo "img" se estarian promediando los pixels con pixels que son un promedio de por si. Entonces se guarda el resultado en este espacio pedido usando malloc, y luego de procesar toda la image, se copia todo el contenido de este resultado a la imagen original usando un loop construido con jumps condicionales, y luego se hace un free de esta memoria.
\newline

Tambien algo muy importante es que, como se ve en el pseudocodigo, uno siempre carga de a 4 pixeles, descartando el cuarto pixel en el proceso posterior. Esto va a comportarse de forma no deseada al llegar al x = n - 2, ya que al cargar el registro estarias agarrando datos que no pertenecen a la fila deseada, esto no es un problema al principio, ya que se estaria cargando el primer pixel de la siguiente fila, lo cual esta permitido. Pero al llegar tambien al y = n - 2 uno estaria tratando de cargar algo que no nos pertenece, ya que estariamos en la ultima fila de la imagen. Para esto la implementacion se encarga de detectar cuando se llega a este caso en particular (etiqueta "lastpixel") y simplemente se cargan los ultimos 4 pixeles, y se realiza un PSRLDQ para luego seguir normalmente con el algoritmo.

\subsubsection{Implementación 2}

Es...

\begin{figure}[H]
\centering
\includegraphics[scale=0.8]{imagenes/256value.png}
\caption{Contenido de los registros utilizados para multiplicar}
\label{256value}
\end{figure}

El...



\subsubsection{Implementación en C}
%
% BLUR
%

\subsection{Merge}

El merge nos permite a partir de dos imágenes y un valor entre cero y uno, obtener una combinación de estas ultimas según la proporción indicada por el valor.

\subsubsection{Implementación en Assembler 1}

Se recibe por parámetro dos punteros a dos imágenes almacenadas en memoria como una matriz de pixeles. Como los pixeles de estas imágenes ocupan 4 byte, y la cantidad de pixeles de las mismas es multiplo de 4,  utilizando los registros xmm podemos traer de a 4 pixeles. Luego incrementamos los punteros a la imagen en 16 bytes y volvemos a traer los pixeles de memoria. De esta manera tenemos un ciclo principal cuya cantidad de iteraciones es la cantidad de pixeles dividido cuatro. Cada una de estas consiste en levantar de memoria cuatro pixeles y almacenarlos en un registro xmm, cuyo contenido puede verse en la figura \ref{primerXmm}

\begin{figure}[H]
\centering
\includegraphics[scale=0.8]{imagenes/primerXmm.png}
\caption{Contenido del registro xmm al levantar de memoria cuatro pixeles}
\label{primerXmm}
\end{figure}

Luego utilizando la instrucción pshufb y una masara apropiada ordenamos su contenido para que quede como se muestra en la figura \ref{segundoXmm}

\begin{figure}[H]
\centering
\includegraphics[scale=0.8]{imagenes/segundoXmm.png}
\caption{Contenido del registro xmm luego de utilizar la instruccion pshufb}
\label{segundoXmm}
\end{figure}

Utilizamos las instrucciones de desempaquetado de SIMD y un registro xmm lleno de ceros, para desempaquetar la parte alta y baja, obteniendo registros xmm con el contenido como se muestra en la figura \ref{tercerXmm}.


\begin{figure}[H]
\centering
\includegraphics[scale=0.8]{imagenes/tecerXmm.png}
\caption{Contenido resultante de desempaquetar parte alta y baja}
\label{tercerXmm}
\end{figure}

Luego volvemos a desempaquetar parte alta y baja de los dos registros obtenidos, y obtenemos cuatro registros xmm como se indica en la figura \ref{cuartoXmm}.


\begin{figure}[H]
\centering
\includegraphics[scale=0.8]{imagenes/cuartoXmm.png}
\caption{Contenido resultante de desempaquetar parte alta y baja nuevamente}
\label{cuartoXmm}
\end{figure}

Utilizando la instrucción cvtdq2ps convertimos los cuatro valores de los registros \ref{cuartoXmm}, excepto el que contiene los bytes de trasparencia(A), a tipo flotante. El objetivo es multiplicar cada color por value. Para hacer esto, previo al ciclo, utilizando la instrucción shufps, conseguimos en un registro xmm cuatro valores de tipo flotante con el valor que indica el índice de combinación de imágenes pasado por parametro, y en otro cuatro valores con 1-value tal como se indica en la figura \ref{value}.

\begin{figure}[H]
\centering
\includegraphics[scale=0.8]{imagenes/value.png}
\caption{Contenido de los registros utilizados para multiplicar por value los colores}
\label{value}
\end{figure}


Utilizando la instrucción de simd mulps, multiplicamos los colores transformados a tipo flotante por value.

Se repite el procedimiento para la segunda imagen, excepto que no se desempaqueta el byte de trasparencia(A), ya que solo interesa el byte de trasparencia de la primera imagen. En este caso multiplicamos por 1-value. Sumamos con la instruccion addps los valores obtenidos en la multiplicación, para los colores azul, verde y rojo. Luego convertimos a enteros de 32 bit, y con la instrucciones packusdw, y packuswb empaquetamos de forma que queden en un xmm los bytes en orden azul, verde, rojo y trasparencia. Este ultimo se consideran los bytes de la primera imagen almacenados en un registro xmm como se muestra la figura \ref{cuartoXmm}. Finalmente con la instrucción pshufb ordenamos los colores para que queden en el mismo orden en que ingresaron, y escribimos en memoria el resultado.

\subsubsection{Implementación 2}

Es analoga a la implementación anterior, pero en este caso se hacen la suma y multiplicación en numeros enteros. Se tiene en cuenta que la multiplicación de dos enteros, da como resultado un entero que puede ocupar el doble de tamaño.

Antes de empezar el ciclo, multiplicamos en punto flotante 256 y value, y al resultado lo convertimos a enteros. En este proceso se pierden decimales. Como value es un numero entre cero y uno, al multiplicar por 256 y pasarlo a enteros, tenemos un valor entre 0 y 256, con lo que ocupa menos de un byte de tamaño. Utilizando la instrucción pshufb y una mascara, almacenamos en un registro xmm 8 replicas de este valor. Luego hacemos la resta en enteros entre 256 y el valor obtenido en la multiplicación. Nuevamente tenemos un valor entero entre 0 y 256 que entra en un byte, almacenamos 8 replicas del mismo en un registro xmm tal como se ve en la figura \ref{256value}. Estos registros seran utilizados para multiplicar los colores.

\begin{figure}[H]
\centering
\includegraphics[scale=0.8]{imagenes/256value.png}
\caption{Contenido de los registros utilizados para multiplicar}
\label{256value}
\end{figure}

El ciclo comienza igual que la implementación anterior, trayendo a un registro xmm 4 pixeles de memoria, ordenandolos con pshufb con una mascara 



\subsubsection{Implementación en C}


\section{Conclusiones y trabajo futuro}


\end{document}

